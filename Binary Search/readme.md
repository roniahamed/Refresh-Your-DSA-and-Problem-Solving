# ЁЯФН **Binary Search Explained: ржХржо рж╕ржоржпрж╝рзЗ рж╕ржарж┐ржХ ржлрж▓рж╛ржлрж▓ ржкрж╛ржУржпрж╝рж╛рж░ ржЬрж╛ржжрзБ!**
> **Refresh DSA and Problem Solving Part 5**
> **ржмрж╛ржЗржирж╛рж░рж┐ рж╕рж╛рж░рзНржЪ: рж╕ржорзНржкрзВрж░рзНржг ржмрж╛ржВрж▓рж╛ ржЧрж╛ржЗржб (ржЙржжрж╛рж╣рж░ржг ржУ ржХрзЛржбрж╕рж╣)**

## ЁЯОп ржнрзВржорж┐ржХрж╛: ржбрж┐ржХрж╢ржирж╛рж░рж┐рж░ ржЙржжрж╛рж╣рж░ржг

ржоржирзЗ ржХрж░рзБржи, ржЖржкржирж╛рж░ ржХрж╛ржЫрзЗ ржПржХржЯрж┐ ржмрж┐рж╢рж╛рж▓ ржбрж┐ржХрж╢ржирж╛рж░рж┐ ржЖржЫрзЗ ржПржмржВ ржЖржкржирж╛ржХрзЗ ржПржХржЯрж┐ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ рж╢ржмрзНржж ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рждрзЗ рж╣ржмрзЗред ржбрж┐ржХрж╢ржирж╛рж░рж┐рж░ рж╢ржмрзНржжржЧрзБрж▓рзЛ ржмрж░рзНржгржорж╛рж▓рж╛ ржЕржирзБржпрж╛ржпрж╝рзА (alphabetically) рж╕рж╛ржЬрж╛ржирзЛ ржерж╛ржХрзЗред

ржЖржкржирж┐ ржХрж┐ ржкрзНрж░ржержо ржкрж╛рждрж╛ ржерзЗржХрзЗ рж╢рзБрж░рзБ ржХрж░рзЗ ржкрзНрж░рждрж┐ржЯрж┐ рж╢ржмрзНржж ржПржХ ржПржХ ржХрж░рзЗ ржЦрзБржБржЬржмрзЗржи? **ржирж╛, ржПрждрзЗ ржЕржирзЗржХ рж╕ржоржпрж╝ рж▓рж╛ржЧржмрзЗред**

рждрж╛рж░ ржмржжрж▓рзЗ, ржЖржкржирж┐ рж╕ржорзНржнржмржд ржпрж╛ ржХрж░ржмрзЗржи:

1. ржбрж┐ржХрж╢ржирж╛рж░рж┐ржЯрж┐рж░ **ржорж╛ржЭрж╛ржорж╛ржЭрж┐** ржПржХржЯрж┐ ржкрж╛рждрж╛ ржЦрзБрж▓ржмрзЗржи
2. рж╕рзЗржЗ ржкрзГрж╖рзНржарж╛рж░ рж╢ржмрзНржжржЯрж┐ ржжрзЗржЦржмрзЗржи
3. ржпржжрж┐ ржЖржкржирж╛рж░ ржЦрзЛржБржЬрж╛ рж╢ржмрзНржжржЯрж┐ ржР ржорж╛ржЭрзЗрж░ рж╢ржмрзНржжрзЗрж░ ржкрж░рзЗ ржЖрж╕рзЗ, рждрж╛рж╣рж▓рзЗ ржмржЗржпрж╝рзЗрж░ ржжрзНржмрж┐рждрзАржпрж╝рж╛рж░рзНржзрзЗ ржЦрзБржБржЬржмрзЗржи
4. ржЖрж░ ржпржжрж┐ ржЖржкржирж╛рж░ рж╢ржмрзНржжржЯрж┐ ржорж╛ржЭрзЗрж░ рж╢ржмрзНржжрзЗрж░ ржЖржЧрзЗ ржЖрж╕рзЗ, рждрж╛рж╣рж▓рзЗ ржмржЗржпрж╝рзЗрж░ ржкрзНрж░ржержорж╛рж░рзНржзрзЗ ржЦрзБржБржЬржмрзЗржи

ржПржЗ ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ржЯрж┐ ржмрж╛рж░ржмрж╛рж░ ржХрж░рждрзЗ ржерж╛ржХржмрзЗржи, ржкрзНрж░рждрж┐ржмрж╛рж░ ржЦрзЛржБржЬрж╛рж░ ржЬрж╛ржпрж╝ржЧрж╛ржЯрж┐ржХрзЗ ржЕрж░рзНржзрзЗржХ ржХрж░рзЗ ржлрзЗрж▓ржмрзЗржиред

**ЁЯОЙ ржмрж╛ржЗржирж╛рж░рж┐ рж╕рж╛рж░рзНржЪ ржарж┐ржХ ржПржЗ ржкржжрзНржзрждрж┐рждрзЗржЗ ржХрж╛ржЬ ржХрж░рзЗ!**

---

## ЁЯУЪ ржмрж╛ржЗржирж╛рж░рж┐ рж╕рж╛рж░рзНржЪ ржХрзА? (What is Binary Search?)

### рж╕ржВржЬрзНржЮрж╛:
ржмрж╛ржЗржирж╛рж░рж┐ рж╕рж╛рж░рзНржЪ (Binary Search) рж╣рж▓рзЛ ржПржХржЯрж┐ ржЕрждрзНржпржирзНржд ржХрж╛рж░рзНржпржХрж░ (efficient) рж╕рж╛рж░рзНржЪрж┐ржВ ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо ржпрж╛ ржПржХржЯрж┐ **рж╕рж╛ржЬрж╛ржирзЛ (sorted) ржЕрзНржпрж╛рж░рзЗ ржмрж╛ рж▓рж┐рж╕рзНржЯ** ржерзЗржХрзЗ ржХрзЛржирзЛ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржЙржкрж╛ржжрж╛ржи (element) ржжрзНрж░рзБржд ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рж╛рж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГржд рж╣ржпрж╝ред

### ЁЯФС Binary Search ржПрж░ ржорзВрж▓ ржирзАрждрж┐ рж╣рж▓рзЛ:

1.  Array ржПрж░ ржорж╛ржЭрзЗрж░ element ржЯрж┐ ржирж┐ржпрж╝рзЗ target ржПрж░ рж╕рж╛ржерзЗ рждрзБрж▓ржирж╛ ржХрж░рж╛
2.  ржпржжрж┐ ржорж╛ржЭрзЗрж░ element ржЯрж┐ target ржПрж░ ржЪрзЗржпрж╝рзЗ ржмржбрж╝ рж╣ржпрж╝, рждрж╛рж╣рж▓рзЗ ржмрж╛ржо ржЕржВрж╢рзЗ ржЦрзЛржБржЬрж╛
3.  ржпржжрж┐ ржорж╛ржЭрзЗрж░ element ржЯрж┐ target ржПрж░ ржЪрзЗржпрж╝рзЗ ржЫрзЛржЯ рж╣ржпрж╝, рждрж╛рж╣рж▓рзЗ ржбрж╛ржи ржЕржВрж╢рзЗ ржЦрзЛржБржЬрж╛
4.  ржпржжрж┐ ржкрзЗржпрж╝рзЗ ржпрж╛ржЗ, рждрж╛рж╣рж▓рзЗ index return ржХрж░рж╛
5.  ржкрзНрж░рждрж┐ржмрж╛рж░ search space ржЕрж░рзНржзрзЗржХ рж╣ржпрж╝рзЗ ржпрж╛ржпрж╝
- **рж╕ржмржЪрзЗржпрж╝рзЗ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг рж╢рж░рзНржд:** ржбрзЗржЯрж╛ ржЕржмрж╢рзНржпржЗ sorted ржерж╛ржХрждрзЗ рж╣ржмрзЗ

---
## тЪЩя╕П ржмрж╛ржЗржирж╛рж░рж┐ рж╕рж╛рж░рзНржЪ ржХрзАржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ?

### рждрж┐ржиржЯрж┐ ржкржпрж╝рзЗржирзНржЯрж╛рж░:
1. **left:** рж╕рж╛рж░рзНржЪ рж░рзЗржЮрзНржЬрзЗрж░ рж╢рзБрж░рзБрж░ ржЗржиржбрзЗржХрзНрж╕
2. **right:** рж╕рж╛рж░рзНржЪ рж░рзЗржЮрзНржЬрзЗрж░ рж╢рзЗрж╖рзЗрж░ ржЗржиржбрзЗржХрзНрж╕
3. **mid:** left ржУ right-ржПрж░ ржорж╛ржЭржЦрж╛ржирзЗрж░ ржЗржиржбрзЗржХрзНрж╕

### ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржорзЗрж░ ржзрж╛ржкрж╕ржорзВрж╣:

```
1. left = 0, right = array_length - 1
2. While left тЙд right:
   a. mid = left + (right - left) ├╖ 2
   b. If array[mid] == target: return mid
   c. If array[mid] < target: left = mid + 1
   d. If array[mid] > target: right = mid - 1
3. Return -1 (not found)
```

---

## ЁЯФН Step-by-Step ржЙржжрж╛рж╣рж░ржг

**ржЕрзНржпрж╛рж░рзЗ:** [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]  
**ржЯрж╛рж░рзНржЧрзЗржЯ:** 23

### ржнрж┐ржЬрзБржпрж╝рж╛рж▓ ржкрзНрж░рзЗржЬрзЗржирзНржЯрзЗрж╢ржи:

```
Step 1: [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
                   тЖС
              left=0, right=9, mid=4
              array[4]=16 < 23 тЖТ go right
              
Step 2: [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
                        тЖС
              left=5, right=9, mid=7  
              array[7]=56 > 23 тЖТ go left
              
Step 3: [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
                     тЖС
              left=5, right=6, mid=5
              array[5]=23 == 23 тЖТ FOUND! ЁЯОЙ
```

**ржлрж▓рж╛ржлрж▓:** Element ржкрж╛ржУржпрж╝рж╛ ржЧрзЗржЫрзЗ index 5-ржП

---

## ЁЯТ╗ Implementation: Iterative vs Recursive

### ЁЯФД Iterative Approach (ржкрзНрж░рж╕рзНрждрж╛ржмрж┐ржд)

```python
def binary_search_iterative(arr, target):
    """
    Time Complexity: O(log n)
    Space Complexity: O(1)
    """
    left, right = 0, len(arr) - 1
    
    while left <= right:
        # Integer overflow ржПржбрж╝рж╛ржирзЛрж░ ржЬржирзНржп
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1  # ржбрж╛ржи ржжрж┐ржХрзЗ ржЦрзЛржБржЬрзЛ
        else:
            right = mid - 1  # ржмрж╛ржо ржжрж┐ржХрзЗ ржЦрзЛржБржЬрзЛ
    
    return -1  # ржирж╛ ржкрзЗрж▓рзЗ

# ЁЯзк Test
arr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
result = binary_search_iterative(arr, 23)
print(f"тЬЕ Element found at index: {result}")  # Output: 5
```

### ЁЯФБ Recursive Approach

```python
def binary_search_recursive(arr, left, right, target):
    """
    Time Complexity: O(log n)
    Space Complexity: O(log n) - call stack
    """
    if left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            return binary_search_recursive(arr, mid + 1, right, target)
        else:
            return binary_search_recursive(arr, left, mid - 1, target)
    
    return -1

# ЁЯзк Test
arr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
result = binary_search_recursive(arr, 0, len(arr) - 1, 23)
print(f"тЬЕ Element found at index: {result}")  # Output: 5
```

---

## ЁЯУИ Time ржПржмржВ Space Complexity
-   **Time Complexity: O(log n)**
    -   ржкрзНрж░рждрж┐ржЯрж┐ ржзрж╛ржкрзЗ ржЖржорж░рж╛ рж╕рж╛рж░рзНржЪ рж╕рзНржкрзЗрж╕ржХрзЗ ржЕрж░рзНржзрзЗржХ ржХрж░рзЗ ржлрзЗрж▓рж┐ред ржпржжрж┐ `n` рж╕ржВржЦрзНржпржХ ржЙржкрж╛ржжрж╛ржи ржерж╛ржХрзЗ, рждржмрзЗ ржкрзНрж░ржержо ржзрж╛ржкрзЗ `n/2`, ржжрзНржмрж┐рждрзАржпрж╝ ржзрж╛ржкрзЗ `n/4`, ... ржПржнрж╛ржмрзЗ `1` ржирж╛ рж╣ржУржпрж╝рж╛ ржкрж░рзНржпржирзНржд ржЪрж▓рждрзЗ ржерж╛ржХрзЗред ржПржЗ ржзрж╛ржк рж╕ржВржЦрзНржпрж╛ржХрзЗ `k` ржзрж░рж▓рзЗ, `n / 2^k = 1` ржмрж╛ `n = 2^k`ред ржЙржнржпрж╝ ржжрж┐ржХрзЗ `log` ржирж┐рж▓рзЗ `k = logтВВ(n)` рж╣рзЯред рждрж╛ржЗ ржЯрж╛ржЗржо ржХржоржкрзНрж▓рзЗржХрзНрж╕рж┐ржЯрж┐ `O(log n)`ред
-   **Space Complexity:**
    -   **Iterative Approach: O(1)** ржХрж╛рж░ржг ржЖржорж░рж╛ ржХрзЗржмрж▓ ржХржпрж╝рзЗржХржЯрж┐ ржнрзНржпрж╛рж░рж┐ржпрж╝рзЗржмрж▓ (`left`, `right`, `mid`) ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж┐, ржпрж╛ ржЗржиржкрзБржЯрзЗрж░ ржЖржХрж╛рж░рзЗрж░ ржЙржкрж░ ржирж┐рж░рзНржнрж░рж╢рзАрж▓ ржиржпрж╝ред
    -   **Recursive Approach: O(log n)** ржХрж╛рж░ржг ржкрзНрж░рждрж┐ржЯрж┐ рж░рж┐ржХрж╛рж░рзНрж╕рж┐ржн ржХрж▓ ржлрж╛ржВрж╢ржи ржХрж▓ рж╕рзНржЯрзНржпрж╛ржХрзЗ (call stack) ржЬрж╛ржпрж╝ржЧрж╛ ржирзЗржпрж╝ред рж╕ржмржЪрзЗржпрж╝рзЗ ржЦрж╛рж░рж╛ржк ржЕржмрж╕рзНржерж╛ржпрж╝ `log n` рж╕ржВржЦрзНржпржХ ржХрж▓ рж╕рзНржЯрзНржпрж╛ржХ рж╣рждрзЗ ржкрж╛рж░рзЗред

### ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд ржмрж┐рж╢рзНрж▓рзЗрж╖ржг:

| Approach | Time Complexity | Space Complexity | ржкрзНрж░рж╕рзНрждрж╛ржмрж┐ржд |
|:---:|:---:|:---:|:---:|
| **Iterative** | O(log n) | **O(1)** | тЬЕ Yes |
| **Recursive** | O(log n) | O(log n) | тЪая╕П Stack overhead |

### ржХрзЗржи O(log n)?
```
n = 1000 elements
Step 1: 1000 тЖТ 500
Step 2: 500 тЖТ 250  
Step 3: 250 тЖТ 125
...
Step 10: 2 тЖТ 1

Total steps = тМКlogтВВ(1000)тМЛ + 1 тЙИ 10 steps
```

---


## ЁЯУК рж▓рж┐ржирж┐ржпрж╝рж╛рж░ рж╕рж╛рж░рзНржЪрзЗрж░ ржЪрзЗржпрж╝рзЗ ржмрж╛ржЗржирж╛рж░рж┐ рж╕рж╛рж░рзНржЪ ржХрзЗржи ржнрж╛рж▓рзЛ?
рж▓рж┐ржирж┐ржпрж╝рж╛рж░ рж╕рж╛рж░рзНржЪ (Linear Search) рж╣рж▓рзЛ рж╕ржмржЪрзЗржпрж╝рзЗ рж╕рж╣ржЬ ржЙржкрж╛ржпрж╝, ржпрзЗржЦрж╛ржирзЗ ржПржХржЯрж┐ рж▓рж┐рж╕рзНржЯрзЗрж░ ржкрзНрж░ржержо ржерзЗржХрзЗ рж╢рзЗрж╖ ржкрж░рзНржпржирзНржд ржкрзНрж░рждрж┐ржЯрж┐ ржЙржкрж╛ржжрж╛ржи ржПржХ ржПржХ ржХрж░рзЗ ржЪрзЗржХ ржХрж░рж╛ рж╣ржпрж╝ред ржпржжрж┐ рж▓рж┐рж╕рзНржЯрзЗ рзз рж▓ржХрзНрж╖ ржЖржЗржЯрзЗржо ржерж╛ржХрзЗ, рждржмрзЗ рж╕ржмржЪрзЗржпрж╝рзЗ ржЦрж╛рж░рж╛ржк ржЕржмрж╕рзНржерж╛ржпрж╝ рзз рж▓ржХрзНрж╖ ржмрж╛рж░ ржЪрзЗржХ ржХрж░рждрзЗ рж╣рждрзЗ ржкрж╛рж░рзЗред
ржЕржирзНржпржжрж┐ржХрзЗ, ржмрж╛ржЗржирж╛рж░рж┐ рж╕рж╛рж░рзНржЪ ржкрзНрж░рждрж┐ ржзрж╛ржкрзЗ рждрж╛рж░ рж╕рж╛рж░рзНржЪ рж╕рзНржкрзЗрж╕ (search space) ржмрж╛ ржЦрзЛржБржЬрж╛рж░ ржЬрж╛ржпрж╝ржЧрж╛ржХрзЗ ржЕрж░рзНржзрзЗржХ ржХрж░рзЗ ржлрзЗрж▓рзЗред ржлрж▓рзЗ ржПржЯрж┐ ржЕржирзЗржХ ржмрзЗрж╢рж┐ ржХрж╛рж░рзНржпржХрж░ред

ржЖрж╕рзБржи рззрзмржЯрж┐ ржЙржкрж╛ржжрж╛ржирзЗрж░ ржПржХржЯрж┐ рж▓рж┐рж╕рзНржЯ ржжрж┐ржпрж╝рзЗ ржжрзЗржЦрж┐:
-   **рж▓рж┐ржирж┐ржпрж╝рж╛рж░ рж╕рж╛рж░рзНржЪ:** рж╕ржмржЪрзЗржпрж╝рзЗ ржЦрж╛рж░рж╛ржк ржЕржмрж╕рзНржерж╛ржпрж╝ **рззрзм** ржЯрж┐ ржзрж╛ржк ржкрзНрж░ржпрж╝рзЛржЬржиред
-   **ржмрж╛ржЗржирж╛рж░рж┐ рж╕рж╛рж░рзНржЪ:**
    -   ржзрж╛ржк рзз: ржорж╛ржЭрзЗрж░ ржЙржкрж╛ржжрж╛ржи ржЪрзЗржХ ржХрж░рж╛рж░ ржкрж░ ржмрж╛ржХрж┐ ржерж╛ржХрзЗ **рзо** ржЯрж┐ ржЙржкрж╛ржжрж╛ржиред
    -   ржзрж╛ржк рзи: ржЖржмрж╛рж░ ржорж╛ржЭрзЗрж░ржЯрж┐ ржЪрзЗржХ ржХрж░рж╛рж░ ржкрж░ ржмрж╛ржХрж┐ ржерж╛ржХрзЗ **рзк** ржЯрж┐ ржЙржкрж╛ржжрж╛ржиред
    -   ржзрж╛ржк рзй: ржПрж░ржкрж░ ржмрж╛ржХрж┐ ржерж╛ржХрзЗ **рзи** ржЯрж┐ ржЙржкрж╛ржжрж╛ржиред
    -   ржзрж╛ржк рзк: рж╢рзЗрж╖рзЗ **рзз** ржЯрж┐ ржЙржкрж╛ржжрж╛ржи ржмрж╛ржХрж┐ ржерж╛ржХрзЗ ржПржмржВ ржЖржорж░рж╛ ржЙрждрзНрждрж░ ржкрзЗржпрж╝рзЗ ржпрж╛ржЗред

ржорж╛рждрзНрж░ **рзк** ржЯрж┐ ржзрж╛ржкрзЗ ржмрж╛ржЗржирж╛рж░рж┐ рж╕рж╛рж░рзНржЪ рждрж╛рж░ ржХрж╛ржЬ рж╕ржорзНржкржирзНржи ржХрж░рзЗред рж▓рж┐рж╕рзНржЯ ржпржд ржмржбрж╝ рж╣ржмрзЗ, ржПржЗ ржкрж╛рж░ржлрж░ржорзНржпрж╛ржирзНрж╕рзЗрж░ ржкрж╛рж░рзНржержХрзНржпржУ рждржд ржмрж╛ржбрж╝ржмрзЗред
### рждрзБрж▓ржирж╛ржорзВрж▓ржХ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг:

| ржбрзЗржЯрж╛ рж╕рж╛ржЗржЬ | рж▓рж┐ржирж┐ржпрж╝рж╛рж░ рж╕рж╛рж░рзНржЪ | ржмрж╛ржЗржирж╛рж░рж┐ рж╕рж╛рж░рзНржЪ | ржкрж╛рж░рзНржержХрзНржп |
|:---:|:---:|:---:|:---:|
| 16 | 16 steps | 4 steps | **4x faster** |
| 1,000 | 1,000 steps | 10 steps | **100x faster** |
| 1,000,000 | 1,000,000 steps | 20 steps | **50,000x faster** |

### ЁЯУИ ржЧрж╛ржгрж┐рждрж┐ржХ ржкрзНрж░ржорж╛ржг:
- **рж▓рж┐ржирж┐ржпрж╝рж╛рж░ рж╕рж╛рж░рзНржЪ:** O(n) - рж╕ржмржЪрзЗржпрж╝рзЗ ржЦрж╛рж░рж╛ржк ржЕржмрж╕рзНржерж╛ржпрж╝ n ржмрж╛рж░ ржЪрзЗржХ
- **ржмрж╛ржЗржирж╛рж░рж┐ рж╕рж╛рж░рзНржЪ:** O(log n) - рж╕ржмржЪрзЗржпрж╝рзЗ ржЦрж╛рж░рж╛ржк ржЕржмрж╕рзНржерж╛ржпрж╝ logтВВ(n) ржмрж╛рж░ ржЪрзЗржХ

---

## ЁЯОЫя╕П ржмрж╛ржЗржирж╛рж░рж┐ рж╕рж╛рж░рзНржЪрзЗрж░ ржмрж┐ржнрж┐ржирзНржи Variation

### 1я╕ПтГг First Occurrence (Lower Bound)

**рж╕ржорж╕рзНржпрж╛:** ржпржжрж┐ ржЕрзНржпрж╛рж░рзЗрждрзЗ ржПржХржЯрж┐ рж╕ржВржЦрзНржпрж╛ ржПржХрж╛ржзрж┐ржХржмрж╛рж░ ржерж╛ржХрзЗ, рждрж╛рж╣рж▓рзЗ рждрж╛рж░ ржкрзНрж░ржержо ржЕржмрж╕рзНржерж╛ржиржЯрж┐ ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рж╛ред

**рж▓ржЬрж┐ржХ:** ржпржЦржи `arr[mid] == target` рж╣рзЯ, рждржЦржи ржЖржорж░рж╛ ржерзЗржорзЗ ржпрж╛ржЗ ржирж╛ред ржЖржорж░рж╛ ржнрж╛ржмрж┐, "ржПржЯрж┐ ржПржХржЯрж┐ рж╕ржорзНржнрж╛ржмрзНржп ржЙрждрзНрждрж░, ржХрж┐ржирзНрждрзБ ржПрж░ ржмрж╛ржо ржжрж┐ржХрзЗ ржЖрж░ржУ ржерж╛ржХрждрзЗ ржкрж╛рж░рзЗред" рждрж╛ржЗ ржЖржорж░рж╛ ржЙрждрзНрждрж░ржЯрж┐ рж╕ржВрж░ржХрзНрж╖ржг ржХрж░рж┐ ржПржмржВ ржмрж╛ржо ржжрж┐ржХрзЗ ржЦрзЛржБржЬрж╛ ржЪрж╛рж▓рж┐ржпрж╝рзЗ ржпрж╛ржЗред

```python
def find_first_occurrence(arr, target):
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            result = mid         # рж╕ржорзНржнрж╛ржмрзНржп answer save ржХрж░рж┐
            right = mid - 1      # ржмрж╛ржо ржжрж┐ржХрзЗ ржЖрж░ржУ ржЦрзЛржБржЬрж┐
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

# ЁЯзк Test: [2, 5, 5, 5, 8, 10], target = 5
# Expected: index 1 (first occurrence)
```

### 2я╕ПтГг Last Occurrence (Upper Bound)

ржЕрзНржпрж╛рж░рзЗрждрзЗ ржПржХржЯрж┐ рж╕ржВржЦрзНржпрж╛рж░ рж╢рзЗрж╖ ржЕржмрж╕рзНржерж╛ржиржЯрж┐ ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рж╛ред

**рж▓ржЬрж┐ржХ:** ржпржЦржи `arr[mid] == target` рж╣рзЯ, ржЖржорж░рж╛ ржнрж╛ржмрж┐, "ржПржЯрж┐ ржПржХржЯрж┐ рж╕ржорзНржнрж╛ржмрзНржп ржЙрждрзНрждрж░, ржХрж┐ржирзНрждрзБ ржПрж░ ржбрж╛ржи ржжрж┐ржХрзЗ ржЖрж░ржУ ржерж╛ржХрждрзЗ ржкрж╛рж░рзЗред" рждрж╛ржЗ ржЖржорж░рж╛ ржЙрждрзНрждрж░ржЯрж┐ рж╕ржВрж░ржХрзНрж╖ржг ржХрж░рзЗ ржбрж╛ржи ржжрж┐ржХрзЗ ржЦрзЛржБржЬрж╛ ржЪрж╛рж▓рж┐ржпрж╝рзЗ ржпрж╛ржЗред
```python
def find_last_occurrence(arr, target):
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            result = mid         # рж╕ржорзНржнрж╛ржмрзНржп answer save ржХрж░рж┐
            left = mid + 1       # ржбрж╛ржи ржжрж┐ржХрзЗ ржЖрж░ржУ ржЦрзЛржБржЬрж┐
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result
```

### 3я╕ПтГг Search Insert Position

**рж╕ржорж╕рзНржпрж╛:** ржпржжрж┐ ржЯрж╛рж░рзНржЧрзЗржЯ ржЕрзНржпрж╛рж░рзЗрждрзЗ ржерж╛ржХрзЗ, рждржмрзЗ рждрж╛рж░ ржЗржиржбрзЗржХрзНрж╕ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рж╛ред ржпржжрж┐ ржирж╛ ржерж╛ржХрзЗ, рждрж╛рж╣рж▓рзЗ ржПржЯрж┐ ржХрзЛржи ржЗржиржбрзЗржХрзНрж╕рзЗ ржврзЛржХрж╛ржирзЛ (insert) ржЙржЪрж┐ржд рждрж╛ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рж╛ред

**рж▓ржЬрж┐ржХ:** ржПржЯрж┐ Lower Bound-ржПрж░ ржорждрзЛржЗред рж▓рзБржк рж╢рзЗрж╖ рж╣рж▓рзЗ, `left` ржкрзЯрзЗржирзНржЯрж╛рж░ржЯрж┐ ржарж┐ржХ рж╕рзЗржЗ ржЕржмрж╕рзНржерж╛ржирзЗ ржерж╛ржХрзЗ ржпрзЗржЦрж╛ржирзЗ ржЯрж╛рж░рзНржЧрзЗржЯржЯрж┐ ржерж╛ржХрж╛ ржЙржЪрж┐ржд ржЫрж┐рж▓ред

```python
def search_insert_position(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return left  # Insert position

# ЁЯзк Test: [1, 3, 5, 6], target = 4
# Expected: index 2 (insert between 3 and 5)
```

---

## тЪая╕П Edge Cases ржПржмржВ Common Mistakes

### Edge Cases:

1.  **Empty array:** `arr = []`
2.  **Single element:** `arr = [5]`
3.  **Target smaller than first element:** `target < arr[0]`
4.  **Target larger than last element:** `target > arr[-1]`
5.  **Duplicate elements**

### ЁЯЪи Infinite Loop ржПрж░ ржХрж╛рж░ржгрж╕ржорзВрж╣:

#### тЭМ ржнрзБрж▓ Mid Calculation:
```python
# Wrong - Integer overflow risk
mid = (left + right) // 2

# тЬЕ Correct
mid = left + (right - left) // 2
```

#### тЭМ ржнрзБрж▓ Boundary Update:
```python
# Wrong - Can cause infinite loop
if arr[mid] < target:
    left = mid      # Should be mid + 1
else:
    right = mid     # Should be mid - 1
```

### ЁЯЫбя╕П Safe Binary Search Template:

```python
def safe_binary_search(arr, target):
    # Edge case handling
    if not arr:
        return -1
    
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1  # Always +1
        else:
            right = mid - 1  # Always -1
    
    return -1
```

---

## ЁЯОп ржХржЦржи Binary Search ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЗржи?


### тЬЕ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи ржпржЦржи:
- ржбрзЗржЯрж╛ **sorted** ржЕржмрж╕рзНржерж╛ржпрж╝ ржЖржЫрзЗ
- **Large dataset** ржП ржжрзНрж░рзБржд search ржкрзНрж░ржпрж╝рзЛржЬржи
- **O(log n)** time complexity ржЪрж╛ржи
- **Random access** рж╕рж╛ржкрзЛрж░рзНржЯ ржЖржЫрзЗ (Array, Vector)

### тЭМ ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЗржи ржирж╛ ржпржЦржи:
- ржбрзЗржЯрж╛ **unsorted**
- **Small dataset** (< 50 elements)
- **Frequent insert/delete** operations
- **Linked List** ржПрж░ ржорждрзЛ sequential access structure

---

## ЁЯПЖ Binary Search Practice Problems

### ЁЯУЛ Essential Problems (Neetcode 150 & Grind 169)

| # | Problem | Difficulty | LeetCode | Status |
|:---:|:---|:---:|:---:|:---:|
| 1 | Binary Search | ЁЯЯв Easy | [704](https://leetcode.com/problems/binary-search/) | тмЬ |
| 2 | Search Insert Position | ЁЯЯв Easy | [35](https://leetcode.com/problems/search-insert-position/) | тмЬ |
| 3 | First Bad Version | ЁЯЯв Easy | [278](https://leetcode.com/problems/first-bad-version/) | тмЬ |
| 4 | Search a 2D Matrix | ЁЯЯб Medium | [74](https://leetcode.com/problems/search-a-2d-matrix/) | тмЬ |
| 5 | Find Peak Element | ЁЯЯб Medium | [162](https://leetcode.com/problems/find-peak-element/) | тмЬ |
| 6 | Search in Rotated Sorted Array | ЁЯЯб Medium | [33](https://leetcode.com/problems/search-in-rotated-sorted-array/) | тмЬ |
| 7 | Find First and Last Position | ЁЯЯб Medium | [34](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/) | тмЬ |
| 8 | Koko Eating Bananas | ЁЯЯб Medium | [875](https://leetcode.com/problems/koko-eating-bananas/) | тмЬ |
| 9 | Time Based Key-Value Store | ЁЯЯб Medium | [981](https://leetcode.com/problems/time-based-key-value-store/) | тмЬ |
| 10 | Median of Two Sorted Arrays | ЁЯФ┤ Hard | [4](https://leetcode.com/problems/median-of-two-sorted-arrays/) | тмЬ |

### ЁЯОп Learning Path:
1. **Week 1:** Easy problems (1-3)
2. **Week 2:** Medium variations (4-6)  
3. **Week 3:** Advanced applications (7-9)
4. **Week 4:** Hard challenge (10)

---

## ЁЯза ржоржирзЗ рж░рж╛ржЦрж╛рж░ ржХрзМрж╢рж▓

### ЁЯУЭ Golden Rules:

1. **ЁЯФС Pre-condition:** Array ржЕржмрж╢рзНржпржЗ sorted
2. **ЁЯОп Mid calculation:** `left + (right - left) // 2`
3. **ЁЯФД Boundary update:** рж╕ржмрж╕ржоржпрж╝ `+1` ржмрж╛ `-1`
4. **ЁЯЫбя╕П Edge cases:** Empty array, single element
5. **ЁЯОи Template:** ржкрзНрж░рждрж┐ржЯрж┐ variation ржПрж░ template ржорзБржЦрж╕рзНрже ржХрж░рзБржи

### ЁЯЪА Pro Tips:

```python
# ЁЯТб Mnemonic: "LMR" (Left-Mid-Right)
# L: left pointer
# M: mid calculation
# R: right pointer update

# ЁЯОп Remember: Binary search = "Divide and conquer"
# Each step eliminates half of the possibilities
```

### ЁЯФН Debug Checklist:
- [ ] Array is sorted?
- [ ] Correct mid calculation?
- [ ] Proper boundary updates?
- [ ] Edge cases handled?
- [ ] Loop termination guaranteed?

---

## ЁЯОЙ рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк

Binary Search ржПржХржЯрж┐ fundamental algorithm ржпрж╛:

- **тЪб Faster:** O(log n) time complexity
- **ЁЯТ╛ Memory efficient:** O(1) space (iterative)
- **ЁЯОп Precision:** Sorted data рждрзЗ 100% ржХрж╛рж░рзНржпржХрж░
- **ЁЯФз Versatility:** ржмрж┐ржнрж┐ржирзНржи problem pattern ржП applicable

**ЁЯЪА ржЖржЬржЗ practice рж╢рзБрж░рзБ ржХрж░рзБржи ржПржмржВ DSA journey рждрзЗ ржПржХ ржзрж╛ржк ржПржЧрж┐ржпрж╝рзЗ ржпрж╛ржи!**

---

## ЁЯУЮ рж╕рж╛рж╣рж╛ржпрзНржп ржкрзЗрждрзЗ:

ржПржЗ ржЯрж┐ржЙржЯрзЛрж░рж┐ржпрж╝рж╛рж▓ ржирж┐ржпрж╝рзЗ ржХрзЛржирзЛ ржкрзНрж░рж╢рзНржи ржерж╛ржХрж▓рзЗ ржмрж╛ ржЖрж░ржУ advanced topics ржЬрж╛ржирждрзЗ ржЪрж╛ржЗрж▓рзЗ ржЬрж╛ржирж╛ржиред 

**Happy Coding! ЁЯОК**

---

*ЁЯУЪ ржПржЗ ржЧрж╛ржЗржбржЯрж┐ ржнрж╛рж▓рзЛ рж▓рж╛ржЧрж▓рзЗ ржмржирзНржзрзБржжрзЗрж░ рж╕рж╛ржерзЗ рж╢рзЗржпрж╝рж╛рж░ ржХрж░рзБржи ржПржмржВ ржПржХрж╕рж╛ржерзЗ programming skills ржЙржирзНржиржд ржХрж░рзБржи!*